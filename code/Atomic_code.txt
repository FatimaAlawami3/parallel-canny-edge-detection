#include <string>
#include <iostream>
#include <cmath>
#include <atomic>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <omp.h>

using namespace cv;
using namespace std;

void gaussian_kernel(float** gauss, int padd, float sigma){
    float coeff = 2.0f * pow(sigma, 2.0f);
    int k_size = 1 + 2*padd;
    float sum = 0.0f;

    for(int i = 0; i < k_size; ++i){
        for(int j = 0; j < k_size; ++j){
            gauss[i][j] = exp(-((i-padd)*(i-padd)+(j-padd)*(j-padd)) / coeff);
            sum += gauss[i][j];
        }
    }
    for(int i = 0; i < k_size; ++i){
        for(int j = 0; j < k_size; ++j){
            gauss[i][j] /= sum;
        }
    }
}

void gaussian_blur(float **img, float **blur_img, float **gauss, int h, int w, int k_size){
    int padd = k_size/2;

    #pragma omp parallel for collapse(2) schedule(static)
    for (int i = padd; i < h - padd; i++){
        for (int j = padd; j < w - padd; j++){
            float acc = 0.0f;
            for(int k_i = -padd; k_i <= padd; k_i++){
                for(int k_j = -padd; k_j <= padd; k_j++){
                    acc += img[i+k_i][j+k_j]*gauss[k_i+padd][k_j+padd];
                }
            }
            blur_img[i][j] = acc;
        }
    }
}

static inline void atomic_max(std::atomic<float> &a, float v){
    float cur = a.load(std::memory_order_relaxed);
    while(cur < v && !a.compare_exchange_weak(cur, v, std::memory_order_relaxed)){
    }
}

void sobel_filter(float **img, float **sobel_img, float **theta, int h, int w,
                  long long &strongCount, double &sumGrad, std::atomic<float> &maxGrad){
    int padd = 1;

    float sobel_x[3][3] =
    {
        {-1, 0, 1},
        {-2, 0, 2},
        {-1, 0, 1}
    };
    float sobel_y[3][3] =
    {
        {1, 2, 1},
        {0, 0, 0},
        {-1, -2, -1}
    };

    #pragma omp parallel for collapse(2) schedule(static)
    for(int i = padd; i < h - padd; i++){
        for(int j = padd; j < w - padd; j++){
            float grad_x = 0.0f;
            float grad_y = 0.0f;

            for(int k_i = -padd; k_i <= padd; k_i++){
                for(int k_j = -padd; k_j <= padd; k_j++){
                    grad_x += img[i+k_i][j+k_j]*sobel_x[k_i+padd][k_j+padd];
                    grad_y += img[i+k_i][j+k_j]*sobel_y[k_i+padd][k_j+padd];
                }
            }

            float mag = sqrt(grad_x*grad_x + grad_y*grad_y);
            sobel_img[i][j] = mag;
            theta[i][j] = atan2(grad_y, grad_x);

            #pragma omp atomic
            sumGrad += (double)mag;

            if (mag >= 100.0f){
                #pragma omp atomic
                strongCount++;
            }

            atomic_max(maxGrad, mag);
        }
    }
}

void non_max_suppression(float **img, float **Z, float**theta, int h, int w){
    int padd = 1;

    #pragma omp parallel for collapse(2) schedule(static)
    for(int i = padd; i < h - padd; i++){
        for(int j = padd; j < w - padd; j++){
            float ang = theta[i][j] * 180.0f / (float)M_PI;
            if(ang < 0.0f) ang += 180.0f;

            float q = 255.0f;
            float r = 255.0f;

            if ((ang >= 0.0f && ang < 22.5f) || (ang >= 157.5f && ang <= 180.0f)){
                q = img[i][j+1];
                r = img[i][j-1];
            }
            else if(ang >= 22.5f && ang < 67.5f){
                q = img[i+1][j-1];
                r = img[i-1][j+1];
            }
            else if(ang >= 67.5f && ang < 112.5f){
                q = img[i+1][j];
                r = img[i-1][j];
            }
            else {
                q = img[i-1][j-1];
                r = img[i+1][j+1];
            }

            Z[i][j] = (img[i][j] >= q && img[i][j] >= r) ? img[i][j] : 0.0f;
        }
    }
}

void double_threshold(float **img, float **out_img, int h, int w,
                      float low_thres = 50.0f, float high_thres = 100.0f){
    int padd = 1;

    #pragma omp parallel for collapse(2) schedule(static)
    for(int i = padd; i < h - padd; i++){
        for(int j = padd; j < w - padd; j++){
            float v = img[i][j];
            if(v >= high_thres) out_img[i][j] = high_thres;
            else if(low_thres <= v && v <= high_thres) out_img[i][j] = low_thres;
            else out_img[i][j] = 0.0f;
        }
    }
}

void hysteresis(float **out_img, int h, int w,
                float low_thres = 50.0f, float high_thres = 100.0f){
    bool changed = true;
    int padd = 1;

    while(changed){
        changed = false;

        for(int i = padd; i < h - padd; i++){
            for(int j = padd; j < w - padd; j++){
                if (out_img[i][j] == low_thres){
                    changed = true;

                    if ((out_img[i+1][j-1] == high_thres) || (out_img[i+1][j] == high_thres) ||
                        (out_img[i+1][j+1] == high_thres) || (out_img[i][j-1] == high_thres) ||
                        (out_img[i][j+1] == high_thres) || (out_img[i-1][j-1] == high_thres) ||
                        (out_img[i-1][j] == high_thres) || (out_img[i-1][j+1] == high_thres)){
                        out_img[i][j] = 255.0f;
                    } else {
                        out_img[i][j] = 0.0f;
                    }
                }
            }
        }
    }
}

void test_dataset(vector<String> filenames){
    if (filenames.empty()){
        cout << "No images found." << endl;
        return;
    }

    double gauss_time = 0.0, gradient_time = 0.0, non_max_time = 0.0, thresholding_time = 0.0, hysteresis_time = 0.0;

    int kernel_size = 5;
    int padd = kernel_size/2;

    float **gauss = new float*[kernel_size];
    for(int i = 0; i < kernel_size; ++i){
        gauss[i] = new float[kernel_size];
        for(int j = 0; j < kernel_size; ++j) gauss[i][j] = 0.0f;
    }
    gaussian_kernel(gauss, padd, 1.4f);

    Mat first = imread(filenames[0]);
    Mat first_gray;
    cvtColor(first, first_gray, cv::COLOR_BGR2GRAY);

    int height = first.rows;
    int width  = first.cols;

    float **img   = new float*[height];
    float **img2  = new float*[height];
    float **theta = new float*[height];

    for(int i = 0; i < height; ++i){
        img[i]   = new float[width];
        img2[i]  = new float[width];
        theta[i] = new float[width];
    }

    long long strongCount = 0;
    double sumGrad = 0.0;
    std::atomic<float> maxGrad(0.0f);

    for (size_t f = 0; f < filenames.size(); f++) {
        Mat cv_img = imread(filenames[f]);
        Mat gray_img;
        cvtColor(cv_img, gray_img, cv::COLOR_BGR2GRAY);

        #pragma omp parallel for collapse(2) schedule(static)
        for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                img[i][j]  = (float)gray_img.at<uchar>(i, j);
                img2[i][j] = 0.0f;
                theta[i][j] = 0.0f;
            }
        }

        double start, end;

        start = omp_get_wtime();
        gaussian_blur(img, img2, gauss, height, width, kernel_size);
        end = omp_get_wtime();
        gauss_time += (end - start);

        start = omp_get_wtime();
        sobel_filter(img2, img, theta, height, width, strongCount, sumGrad, maxGrad);
        end = omp_get_wtime();
        gradient_time += (end - start);

        start = omp_get_wtime();
        non_max_suppression(img, img2, theta, height, width);
        end = omp_get_wtime();
        non_max_time += (end - start);

        start = omp_get_wtime();
        double_threshold(img2, img, height, width);
        end = omp_get_wtime();
        thresholding_time += (end - start);

        start = omp_get_wtime();
        hysteresis(img, height, width);
        end = omp_get_wtime();
        hysteresis_time += (end - start);
    }

    double tot_time = gauss_time + gradient_time + non_max_time + thresholding_time + hysteresis_time;
    double avg_time = tot_time / filenames.size();

    printf("Average Blur Execution time = %f sec\n", gauss_time / filenames.size());
    printf("Average Sobel Execution time = %f sec\n", gradient_time / filenames.size());
    printf("Average Non-max Execution time = %f sec\n", non_max_time / filenames.size());
    printf("Average Thresholding Execution time = %f sec\n", thresholding_time / filenames.size());
    printf("Average Hysteresis Execution time = %f sec\n", hysteresis_time / filenames.size());
    printf("Average Canny Execution time = %f sec\n", avg_time);
    printf("Average FPS is: %f\n", (filenames.size()) / tot_time);

    printf("FIXED strongCount = %lld\n", strongCount);
    printf("FIXED sumGrad = %.6f\n", sumGrad);
    printf("FIXED maxGrad = %.6f\n", (double)maxGrad.load());

    for(int i = 0; i < height; ++i){
        delete [] img[i];
        delete [] img2[i];
        delete [] theta[i];
    }
    delete [] img; delete [] img2; delete [] theta;

    for(int i = 0; i < kernel_size; ++i) delete [] gauss[i];
    delete [] gauss;
}

int main(){
    int size = 64;
    for(int i = 1; i < 6; i++){
        String folderpath = "./images/" + to_string(size) + "x" + to_string(size) + "/*.jpg";
        vector<String> filenames;
        cv::glob(folderpath, filenames);

        cout << "===== Image size: " << size << "x" << size
             << " | Number of images: " << filenames.size() << " =====" << endl;

        test_dataset(filenames);
        size *= 2;
    }
    return 0;
}
